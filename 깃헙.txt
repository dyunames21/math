깃헙토큰 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


1.레포지토리 (repository)
  .git 디렉토리(숨겨진 디렉토리) : 레포지토리
  -프로젝트를 관리하기위한 프로젝트 디렉토리의 버전별
    정보를 담고있음 (버전별 프로젝트 모습, 버전별 변경사항등)
  =>커밋이 저장되는곳
 
2.커밋( commit)
  현재 프로젝트 디렉토리의 모습을 사진처럼 레포지토리에 저장됨
  고정된 결과물 자체를 커밋이라고 함
  커밋 한다.... 
  =>프로젝트 디렉토리의 특정 모습을 하나의 버전으로 남기는
    행위, 결과물

  
git init : 비어있는 레포지토리 생성하기
       ->프로젝트 디렉토리의 각 버전이 담길 장소 ( .git)
        이제 깃으로 버전관리가 가능해짐

커밋하기전 꼭 해야하는것?
 -> 깃에게 커밋한사람 알려주기!
  -> 커밋에 대한 정보( 왜 업데이트를 했는지? , 커밋메시지)
  git config user.name "유저이름"
  git config user.email "유저이메일"
 이렇게 설정해두면 커밋을 할때 내 이름과 이메일이 함께 저장됨
  
  git commit -m "커밋에 관한 정보"   ( 옵션 : -m)
  
 
  untracked : 깃에의해 아직 추적 X -> 버전관리 대상이 아닌 항목 존재
  add : 수정된 파일의 모습이 커밋에 포함될것이라 지정해줘야함
  =>git add cal.py
   이러면 cal.py란 파일은 커밋에 반영될 파일로 설정한거임(add 하다)
 
  root-commit : 해당 커밋이 프로젝트의 첫번째 커밋이라는 말
  insertions : 추가된 코드 줄갯수
  
  커밋 주의사항
   -처음 커밋하기전 사용자의 이름과 이메일 주소 설정!
   -커밋메세지 남기기!
   -커밋 하기전 어떤 파일을 커밋에 지정할지 git add를 통해 지정해주기!

   커밋의 순서
  1.working directory 에서 파일을 작성
  2. git add 를 통해 staging area 에 해당 파일을 올림
  3. git commit 을 통해 stagig area에 있는 파일을 가져와 커밋으로 남기기
  
   이 구조에서 2번이 왜 필요한가? 에 대한 대답은
  만약 working directory에서 하나의 파일이 아니라 여러 파일을 동시에 수정 및 작업 후  
    수정한 몇개의 파일만 커밋하고 싶을때 2번 과정이 없다면 항상 모든 파일이 커밋됨
   그래서 수정한 몇개의 파일만 staging area에 올림으로써(add 함으로써) 내가 원하는 부분만 커밋가능한것

  git status : 깃이 인식하고 있는 프로젝트 디렉토리의 현재 상태를 보여줌

  stage : git add로 파일을 staging area에 추가하는것
   => git status를 커밋하기전 써서 staging area에 수정할 파일이 다 들어있는지 확인해보기

  만약 디렉토리를 만들고 디렉토리 내부에 파일작업을 했을 경우
  해당 디렉토리를 add해주면 디렉토리 내부의 모든파일이 다 add됨
  	
  git add .  : 현재 프로젝트 디렉토리 내에서 변경사항이 생긴 모든 파일들을 staging area 에 추가하라는 말


 git에서 파일의 상태는
  -tracked 
  -untracked
 로 나뉨
  tracked는
  -unmodified
  -modified 
  -staged
   상태로 나뉨
 결과적으로 
  -untracked
  -unmodified
  -modified 
  -staged 
 이 네가지 상태에서 add, commit, remove를 통해 상태가 왔다갔다 하는것, 
  

  git reset 파일이름 :  해당파일 git add 취소하기
  => 해당 작업을해도 staging area에서 내려오는것 뿐이지 아직 수정항목을 working area에서 취소한것이 아님
   => git reset : staging area에서만 파일을 제거하는것
   working tree clean : 이전 커밋 이후로 변경사항 없음


   레포지토리를 외부컴퓨터에 저장하는것 
 
   깃헙에 생성한 레포지토리 : 리모트 레포지토리
   내 컴퓨터에 레포지토리 : 로컬 레포지토리

  git push : 로컬 레포지토리에 업데이트된 레포지토리를 리모트 레포지토리도 마찬가지로 업데이트 해주기
    로컬레포지토리의 내용을 그대로 리모트 레포지토리로 반영해준다.

  깃허브는 파일 이름이 README 일 경우 내용을 바로 보여줌

  반대로 
  리모트 레포지토리에서 업데이트 된 내용을 로컬레포지토리에 반영하기 위해선?
  git pull 사용해서 가져오기

 리모트 레포지토리의 사용의미?
 -똑같은 레포지토리를 하나더 생성 : 안정성, 로컬레포지토리가 손실되더라도 리모트레포지토리를 통해 복구가능
 -리모트레포지토리를 통한 협업 가능 : git push와 git pull을 통해 협업 용이함

  원칙적으로 자신만 git push 가능,
  만약 다른 사용자도 git push 가능 하게 할려면 해당 리모트 레포지토리의 collaborator로 지정

  다른프로젝트 가져오기
  - git clone 클론주소
  를 통해서 가져올수있음

 커밋히스토리 : 이때까지 커밋한기록들보기 , 
  git log : 커밋히스토리 보기 
 깃은 커밋을 구분하기위해 커밋 아이디가 각각 존재함  : 커밋해시 

  git log --pretty=oneline : 커밋하나의 정보가 한줄에 출력 
  git show 커밋해시명  : 해당 커밋에서 어떤 변화가 있었는지 직접 보여줌


 이전까지는 커밋을 남길때 -m을 붙이고 커밋메세지를 썼지만
 그냥 git commit 만으로 텍스트 에디터에 커밋메세지를 남겨 복잡하고 긴 커밋메세지 남길수있음

 
 최신커밋 수정하기
  git commit --amend ( 최신커밋을 수정해서 다시 새로운커밋으로 만들기 가능)
  

 하나의 커밋은 하나의 사실만을 가지고 있어야 이해하기 쉽다.

  git config alias.history 'log --pretty=oneline'  라고 한다면 alias를 만들수있다
  앞으로는 git history를 사용하면 해당 긴 내용을 안써도 사용가능함

 
  커밋A와 커밋B사이의 차이점을 찾는방법?
 git diff 커밋아이디A  커밋아이디B  사용하면됨


   HEAD : 어떤 커밋하나를 가르킴
        보통 가장 최근에 한 커밋을 가리킴
        매번 더 새로운 커밋을 가리킴
      =>왜 필요한가?
      만약 헤드가 최신 커밋보다 이전 커밋을 가르키면 working 디렉토리 내부 내용도 이전으로 바뀜
     내가 cat ~ 을 통해 내부 파일을 보면 가장 최신내용으로 출력되는것도
    head가 가장 최근 커밋을 가르키기 때문, 만약 head가 이전 커밋을 가르켰다면 이전 내용이 나올것
   =>HEAD가 가리키는 커밋에 따라 working directory가 구성됨

  
    git reset --hard (가고싶은커밋의 아이디) : 해당 커밋으로 HEAD가 이동함
   => 과거의 커밋을 가르키게할수있다
   -> 과거커밋으로 아예 돌아가고싶을때 
     해당 커밋 이후 작업들이 마음에 안들때나 아예 그 이후 내용을 리셋하고싶을때

 ** git reset을 하더라도 staging area에 있는 것들은 커밋을 하더라도 그것과 상관없이 계속남아있음
    커밋을 해도 staging area에 있는것들은 사라지는게 아니라
   추후 add를 하면 수정, 업데이트 되는것

  
   git reset의 옵션
  --hard :  워킹디렉토리, 스테이징 영역, 레포지토리 셋다 원하는 커밋으로 변환됨
         =>원하는 커밋이후의 작업은 모두 사라진다는말, 복구 불가능
  --mixed :  레포지토리와 스테이지영역은 원하는 커밋으로 변환되지만
                  워킹디렉토리의 내용은 바뀌지않음( 가장최근작업한 모습 그대로라는것, 아주 중요)
         
  --soft : 레포지토리만 원하는 커밋으로 바뀜
        => 헤드의 위치만 과거의 커밋으로 바꾸고, 워킹디렉토리는 그대로 두고싶다
           
    하드 : 전부, 믹스 + 현재 워킹 디렉토리까지 과거의 특정 커밋과 내용 똑같게 하기
    믹스 : 두개,  소프트 + 스테이징 영억을 과거의 특정 커밋과 동일하게 만들기
   소프트 : 하나 영역만 리셋, 헤드가 과거의 특정 커밋을 가르키도록함

  head 기준 커밋 아이디 지칭
 HEAD ^ : 헤드 이전 커밋 지칭
 HEAD~x : x단계 전에 있는 커밋 지칭

 git tag 태그이름 커밋아이디 : 태그 지칭,  



  브랜치
  -하나의 코드관리 흐름
   맨처음한 커밋 : root commit
   git은 root를 시작으로 나무처럼 갈라지는데 
   여러 수정을 거쳐 다양한 기능을 여러 갈래로 목적에 따라 분화 가능, 새로운 프로그램 여러개를 만들기보다
   (ex. 프로그램의 유료, 무료 버전)

  git status시 
  on branch main : 기본으로 셋팅되는 branch
   history란 결국 하나의 branch의 역사를 나타내는것
   
  git branch (브랜치명) 을 통해 새로운 브랜치 생성 가능
  git checkout (브랜치명) 으로 해당 브런치로 이동가능 -> 이 이후로 작업하는것들은 새브렌치에 반영됨
 
  